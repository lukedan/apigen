#include "record_entity.h"

/// \file
/// Implementation of certain methods of \ref apigen::entities::record_entity.

#include "../dependency_analyzer.h"
#include "../entity_registry.h"

namespace apigen::entities {
	bool record_entity::is_move_constructor(clang::CXXConstructorDecl *decl) {
		// ensure that this constructor accepts one parameter
		if (decl->parameters().empty()) {
			return false;
		}
		for (auto it = decl->param_begin() + 1; it != decl->param_end(); ++it) {
			if (!(*it)->hasDefaultArg()) {
				return false;
			}
		}
		// inspect the first parameter
		clang::ParmVarDecl *param = decl->parameters()[0];
		if (param->isParameterPack()) { // ignore packs, this may produce false negatives
			return false;
		}
		auto qty = qualified_type::from_clang_type(param->getType(), nullptr);
		if (
			qty.ref_kind == reference_kind::rvalue_reference &&
			qty.qualifiers.size() == 1 &&
			qty.qualifiers.front() == qualifier::none
			) {
			if (qty.type == decl->getParent()->getTypeForDecl()) {
				return true;
			}
		}
		return false;
	}

	void record_entity::gather_dependencies(entity_registry &reg, dependency_analyzer &queue) {
		auto *def_decl = _decl->getDefinition();
		if (def_decl == nullptr) {
			return;
		}
		for (clang::CXXConstructorDecl *decl : def_decl->ctors()) {
			if (!decl->isDeleted() && is_move_constructor(decl)) {
				_move_constructor = true;
				break;
			}
		}
		// here we iterate over all child entities so that entities in template classes that are not marked as
		// recursive export can be discovered exported correctly
		for (clang::Decl *decl : def_decl->decls()) {
			if (decl->getAccess() != clang::AS_public && !export_private_members()) {
				continue;
			}
			if (auto *named_decl = llvm::dyn_cast<clang::NamedDecl>(decl)) {
				if (auto *method_decl = llvm::dyn_cast<clang::CXXMethodDecl>(named_decl)) {
					clang::FunctionDecl::TemplatedKind tk = method_decl->getTemplatedKind();
					if (
						tk == clang::FunctionDecl::TK_FunctionTemplate ||
						tk == clang::FunctionDecl::TK_DependentFunctionTemplateSpecialization
						) { // template, do not export
						continue;
					}
				} else if (auto *record_decl = llvm::dyn_cast<clang::CXXRecordDecl>(named_decl)) {
					if (record_decl->getDescribedClassTemplate()) { // template, do not export
						continue;
					}
					if (record_decl->isImplicit()) {
						// TODO HACK for some reason an `implicit referenced class` with the same name is generated by
						//           clang *inside* the definition, which causes problems
						continue;
					}
				}
				if (entity *ent = reg.find_or_register_parsed_entity(named_decl)) {
					if (_recursive && !ent->is_excluded()) {
						queue.try_queue(*ent);
					}
				}
			}
		}
	}
}
